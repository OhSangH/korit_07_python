# 상속(Inheritance)

```python
class Person:
    def __init__(self, name):
        self.name = name

    def eat(self, food):
        print(f'{self.name}이(가) {food}를 먹습니다.')


class Student(Person):

    def __init__(self, name, school):
        super().__init__(name)
        self.school = school

    def study(self):
        print(f'{self.name}은(는) {self.school}에서 공부를 합니다.')


potter = Student('해리 포터', '호그와트')
potter.eat('감자')
potter.study()
```

이상의 코드에서 주목해야 할 점은

Student 클래스에 정의되지 않은 메서드인 .eat()을 76 라인에서 호출했다는 점.
Student 클래스의 생성자에서 확인되는 super().__init__(name)입니다.
해당 부분은 슈퍼 클래스의 생성자를 호출하는 방식입니다.
Java에서는 슈퍼 클래스의 생성자 호출 방식이 super()
Java에서 슈퍼 클래스의 메서드 호출 방식 super.메서드명()

```python
def eat(self, food):
    print(f'{self.school}에서', end=' ')
    super().eat(food)
```

만약에 이상과 같이 슈퍼 클래스의 메서드인 .eat()을 override하여 재정의하는 것도 가능합니다. Java와 달리 python에서는 기본적으로 super().을 베이스로 한다는 것을 알 수 있습니다. 생성자나
소멸자가 __ 가 앞뒤로 붙기는 하지만 기본적으로 method라는 사실을 알고 계신다면 Java보다 오히려 더 일괄적인 방식으로 코드를 작성한다는 점도 확인할 수 있겠습니다.

## 생성자

1. 서브클래스의 __init__()
    - 서브 클래스는 슈퍼 클래스가 없으면 존재할 수 없습니다. 그래서 서브 클래스의 생성자를 구현할 때는 '반드시 슈퍼클래스의 생성자를 먼저 호출' 하는 코드를 작성해야만 합니다.
    - 이는 서브 클래스가 호출이 될 경우 슈퍼 클래스가 먼저 호출이 되고 호출된 슈퍼 클래스의 인스턴스가 서브클래스로 전달 되면서 서브 클래스가 생성 된다는 겁니다.
    - 생성자를 호출 했다면 -> 객체가 생성되었다고 봐야하기 때문에 /부모 클래스의 인스턴스와 자식 클래스의 인스턴스가 있다고 봐도 무방합니다. 그런데 별개의 객체냐고 물으면 그럴 수 도 있고 아닐 수 도있습니다.
2. 서브 클래스의 인스턴스 자료형
   - 슈퍼 클래스의 객체는 슈퍼 클래스의 인스턴스 이지만 서브 클래스의 인스턴스는 서브 클래스의 인스턴스 이면서 동시에 슈퍼 클래스의 인스턴스 이기도 하다.
   - 확인 법 : `isinstance(객체명, 클래스명)` -> boolean 반환 