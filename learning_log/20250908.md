```python
class Student:
    def __init__(self, name, student_id):
        self._name: name
        self._student_id = student_id
        self._grade = {}

```

## Python 에서의 Getter/ Setter

1. Java 에서의 Getter/ Setter 생성
    - 그러나 자바에서는 접근 제어자의 개념이 있기에 field에서 private를 선언 했기 때문에 getter/ setter를 사용한다.
    - 문제는 python에서는 접근 제어자라고 할만한 개념이 없기 때문에 모든 객체의 속성이 외부로 노출 됩니다.
2. python에서는 `_속성명` 이라고 명시하게 되면, '내부적으로만 사용하라고 권장 되는 변수' 라고 개발자들 끼리 약속한 개념에 가깝습니다.
3. name vs _name
    - name
        - 공개적으로 접근 가능한 속성 (Public Attribute)
        - 클래스 외부에서 자유롭게 값을 읽고 쓸 수 있으며, 다른 개발자가 이 변수를 직접 사용해도 괜찮음
        - 예시 :`student.name = '김일'` 과 같이 직접 접근하여 사용
    - _name
        - 내부용 또는 비공개 속성(private Attribute)
        - python에는 Java와 같은 업격한 접근 제어자가 없기 때문에 _를 붙여서 '외부에서 접근하지 마세요'같은 의미만 전달한다.
        - 이런 변수는 일반적으로 `@property`데코레이션을 사용하여 Getter와 Setter를 제작한다.

### 예시

```python
class Student:
    def __init__(self, name, student_id):
        self._name = name
        self._student_id = student_id
        self._grade = {}

    # python 버전의 getter
    @property
    def name(self):
        return self._name

    # python 버전의 setter
    @name.setter
    def name(self, value):
        self._name = value


student1 = Student('김일', 2025001)

print(f'학생 이름 : {student1.name}')  # 출력값 : 김일

student1.name = '김영'
print(f'변경된 학생 이름 : {student1.name}')  # 출력값 : 김영
```

- 이상의 코드를 확인하면 _name / name은 서로 다른 개념인데 '_'붙으면 파이썬 언어 내부적으로 동일한 속성으로 처리해 줍니다.
- 다만 더 신기한 것은 객체면.속성명 뒤에 ()가 없음에도 불구하고 그냥 파이썬은 이걸 메서드처럼 처리해준다는 겁니다. 그래서'객체명.속성명'이면 getter처리해 주고 '객체명.속성명 = 데이터'명 setter로
  처리해 준다고 보면된다.
- 이상의 코드라인이 성립하기 위해서 필수적인 부분이 '@property'와 '@속성명.setter'라는 데코레이션이다.

## JPA에서의 객체 생성 vs Python에서의 객체 생성

JPA(Java Persistence API)를 사용한 Java에서는 기본 생성자를 강제합니다(Springboot에서도 적용된다.) 그런데 python에서는 매개변수 생성자를 '권장'하는데 , 이는 두 언어 간의
객체 지향 패러다임과 데이터 관리 방식의 차이에 기인한다.

1. Java(JPA)에서의 기본 생성자
    - JPA는 DB 테이블과 (엔티티)클래스를 매핑하여 객체를 관리합니다. 이 과정에서 JPA가 직접 매개변수를 알 수는 없기 때문에 매개변수가 없는 기본 생성자를 먼저 호출하여 객체를 생성하고, DB에서의
      칼럼 값들을 하나씩 필드에 집어넣어줍니다. 이상을 이유로 JPA는 데이터 관리의 일관성과 효율성을 위해 기본 생성자를 강제합니다.

```java
@Entity
@Data
public class Student{
   private String name;
   private int studentCode;
   
   // 기본 생성자가 강제됨
   public Student(){}
}
public class StudentMain{
   public static main(args[]){
      Student student1 = new Student();
      student.setName('김일');
      student.setStudentCode(2025001);
   }
}
```

이상의 코드라인처럼 일단 필드에 아무런 값이 없는 객체를 생성한 후에, DB 상에서의 테이블에 있는 값들을 일치하는 컬럼명을 조회해서 집어 넣어주는 과정을 거치기 때무넹 기본 생성자를 강제한다.

2. python에서의 매개변수 생성자
    - 파이썬은 Java와 달리 동적 타이핑(Dynamic Typing) 언어라고 해서, 객체를 생성할 때 필수 속성들을 한 번에 초기화 하는 것을 권장합니다.
        1. 객체 무결성 보장 : init 메서드(생성자)에서 모든 필수 매개변수를 받으면, 객체가 생성되는 시점에 이미 완전한 상태를 갖게 됩니다. -> 그 값이 적절한가는 추후에 따져야 하지만
        2. 명확한 코드 작성 : 클래스를 사용하는 사람이 어떤 정보가 필요한지를 명확하게 알 수 있다. 자바처럼 순서대로 하는 것도 아니고 keyword argument를 지원하기도 하니까요

그리고 python과 db의 연동에 있어서 JPA처럼 값을 하나씩 집어 넣기 보다는 ORM(Object-Relational Mapping) 라이브러리를 통해서 객체를 생성할 때 필요한 데이터를 직접 전달하는 방식으로
JPA와의 차이점이 있어 기본생성자를 강제할 필요가 없다.

요약 : JPA는 DB와 연동하기 윟나 길술적 제약으로 인해 기본 생성자를 명시해야하는 귀찮은점이 있는데 (매개변수 생성자를 하나라도 정의하는 순간 기본 생성자도 정의 해야 하니까. 그래서 귀찮으면 롬복의
@NoArgsConstructor를 사용), python 객체의 완전성과 가독성을 중시화는 언어적 특성상 매개변수 생성자를 더 권장합니다.

# 다중 딕셔너리 연습

```python
MENU = {
    '에스프레소': {
        '재료': {
            '물': 50,
            '커피': 18,
        },
        '가격': 1.5,
    },
    '라떼': {
        '재료': {
            '물': 200,
            '커피': 24,
            '우유': 150,
        },
        '가격': 2.5,
    },
    '카푸치노': {
        '재료': {
            '물': 250,
            '커피': 24,
            '우유': 100,
        },
        '가격': 3.0,
    },
}
"""
실행 예
카푸치노에는 우유가 100ml가 들어갑니다.
라고 콘솔에 출력할 수 있도록 카푸치노의 우유량을 추출하는 코드를 작성

에스프레소의 가격을 추출하시오

라떼의 재료를 이름만 출력하시오
"""

print(f'카푸치노에는 우유가 {MENU['카푸치노']['재료']['우유']}ml가 들어갑니다.')
print('에스프레소의 가격을 추출하시오')
print(f'{MENU['에스프레소']['가격']}$')
print('라떼의 재료를 이름만 출력하시오')
print('라떼의 재료 이름은 : ', end='')
for k in MENU['라떼']['재료']:
    print(k, end=' ')

"""
에스프레소 / 라떼 / 카푸치노50잔씩 만들 경우 필요한 커피 우유 물의 양은?
"""
print()

coffee = (MENU['에스프레소']['재료']['커피'] + MENU['카푸치노']['재료']['커피'] + MENU['라떼']['재료']['커피']) * 50
milk = (MENU['카푸치노']['재료']['우유'] + MENU['라떼']['재료']['우유']) * 50
water = (MENU['에스프레소']['재료']['물'] + MENU['카푸치노']['재료']['물'] + MENU['라떼']['재료']['물']) * 50
print(f'커피 / 우유 / 물 : {coffee}ml / {milk}ml / {water}ml')

for_coffee = 0
for_milk = 0
for_water = 0
for k in MENU.keys():
    for_coffee += MENU[k]['재료']['커피']
    for_water += MENU[k]['재료']['물']
    if '우유' in MENU[k]['재료']:
        for_milk += MENU[k]['재료']['우유']

print(f'커피 / 우유 / 물 : {for_coffee * 50}ml / {for_milk * 50}ml / {for_water * 50}ml')

```


# 9월 9일 시험
1과목 - 서답형 / 50문항
2과목 - 코드작성 / 4문항

1과목 - 데이터 분석 기초 기술 활용이지만 그냥 python 서답형이기 때문에 지난 자바 시험과 동일하며 차이점은 리포지토리의 내용을 최대한 담았다는 점. 그래서 로직 자체는 2과목에서 처리할 것이기 때문에 1과목은 되게 기본적은 것들을 물어봄  
문제당 글자수 끽해야 30자 내외. 답변은 사실 상 한 단어에 가깝다.

문자열에서 공백을 기준으로 맨 앞글자만 대문자로 바꿔주는 메서드를 작성하시오.
1번 문제 - Python에서 한 줄 주석을 작성할 때 사용하는 기호를 작성하세요.


2과목 - 빅데이터 분석 결과 시각화
전체 4문항 - 25/25/25/25

1번 문제 - 사용자로부터 전화번호를 입력 받아, 특정 조건에 부합하는지 확인하고 전화번호의 중간 4자리를 출력하는 프로그램을 작성하시오. 전화번호는 하이픈(-)을 포함하여 총 13자리(예:010-1234-5678)여야 한다.
지시사항:
1. 사용자로부터 전화번호를 입력받으세요.
2. 입력된 전화번호의 길이가 13자리가 아닐경우, "유효하지 않은 전화번호 양식입니다."라고 출력하시오.
3. 전화번호가 13자리 일 경우, 전화번호의 중간4자리(예1234)를 추출하여 출력하시오.
4. 출력시 f-string을 사용하시요

실행 예:
전화번호를 입력하시오 >>> 010-9876-5432 전화의 중간 4자리는 9876입니다.
전화번호를 입력하시오 >>> 010-123-4567 유효하지 않는 전화번호 형식입니다.

2번문제 클래스 -> 빈 딕셔너리 사용
3번문제 컬렉션즈 사용하여 문제
