from ch07_classes.constuctor.main import sample

# Collections

## List

- 여러값을 저장할 때 가장 많이 사용. 자료형이 서로 다르더라도 하나의 리스트에 저장이 가능
- 하나의 배열에 동일한 자료형만 저장할 수 있는 Java, C에 비해 파이썬이 가지는 장점중 하나다.

### List의 선언과 조작

- 선언 방식

```python
li1 = [100, 3.14, 'hello']
li2 = list([4, 5, 6, 7, 8, 9, 0])
```

위와 같은 방식으로 선언이 가능하다.

- 슬라이싱

```python
li1 = 'hello'
print(li1[1])
print(li1[2])
print(li1[3])
print(li1[-1])
print(li1[-2])
print(li1[-3])
print(li1[-4])
li2 = list([4, 5, 6, 7, 8, 9, 0])
print(li2[0:4:2])
```

위와 같은 방식으로 리스트를 슬라이싱 가능하다.

- 리스트 요소의 추가와 삭제

```python
scores = [30, 40, 50]  # 리스트 선언
print(scores)  # 출력값 : [30,40,50] 
scores.append(100)  # 가장 뒤에 값을 추가 
print(scores)  # 출력값 : [30,40,50,100] 
scores.insert(0, 90)  # 인덱스 위치에 값을 추가  
print(scores)  # 출력값 : [90, 30, 40, 50, 100]
scores.pop()  # 해당 인덱스를 제거 매개변수가 없을 경우 마지막 요소를 제거
print(scores)  # 출력값 : [90, 30, 40, 50]
scores.remove(90)  # 내부에 일치하는 값을 찾아 제거
print(scores)  # 출력값 : [30, 40, 50]
```

## Tuple

- 튜플의 경우 저장된 값을 변경하지 못하는 list와 비슷하다고 생각 할 수 있다.
- 순서는 있기 때문에 index 넘버와 slicing은 가능하지만 저장된 값 이외에는 추가 / 수정 / 삭제가 불가능하다.

### 선언 및 조작

- 선언 방식

```python
tu1 = (1, 2, 3)
tu2 = tuple((4, 5, 6))
tu3 = 7, 8, 9
```

- element의 추출 및 slicing은 List와 동일하다.
- 튜플은 특성상 추가 / 변경 / 삭제가 불가능하다.
- collection의 개념과 내부 element는 자료형이 서로 다르다

```python
tu4 = 'hello.', 'good morning.', 'my name is', 'kim-il', 'i am', '20 ', 'years old.'
for word in tu4:
    print(word.title(), end=' ')  # 출력 : Hello. Good Morning. My Name Is Kim-Il I Am 20  Years Old. 
print(tu4)  # 출력 : ('hello.', 'good morning.', 'my name is', 'kim-il', 'i am', '20 ', 'years old.') 
```

- 위 코드를 확인하면 tuple은 가공이 불가능 하지만 따로 추출한 element는 가공이 가능해 진다.

## Set

- element들의 중복값을 제거 한다.
- list / tuple 랑은 다르게 index가 존재하지 않으며 이러한 경우에는 비시퀀스라는 표현을 쓴다.

### 선언 및 조작

- 선언

```python
set1 = {1, 2, 3}  # 방식 1
set2 = set({1, 2, 3})  # 방식 2

li = []
tu = ()
se = {}
print(type(li))  # 출력값 : <class 'list'>
print(type(tu))  # 출력값 : <class 'tuple'>
print(type(se))  # 출력값 : <class 'dict'>

se2 = set({})
print(type(se2))  # 출력값 : <class 'set'>

```

- 위 코드에서 확인 할 점은 선언 시 빈 set을 선언 할 경우 {} 만 사용 하면 타입이 딕셔너리로 선언되기 때문에 주의가 필요하다.

- 추가 및 삭제

```python
se3 = {10, 20, 30}
se3.add(50)
print(se3)  # 출력값 : {10, 20, 50, 30}
se3.remove(30)
print(se3)  # 출력값 : {10, 20, 50}

se3.discard(70)
print(se3)  # 출력값 : {10, 20, 50}
```

- 위에 코드를 확인하면 remove와 discard 메서드가 존재 한다.
- remove()의 경우 삭제 할 값을 정확히 입력해 줘야하며 일치하는 값이 없을 경우는 오류가 발생한다.
- discard()의 경우 입력한 값이 없을 경우 그냥 메서드를 종료한다.

## Dictionary

- Java에서의 Map/ JS에서의 Object/ JSON 과 같은 형식이다.
- 딕셔너리의 경우 향상된 for문을 사용을 할 경우 key값이 들어가게 된다.

### 선언 및 조작

- 선언 방법

```python
dict1 = {
    '이름': '김일',
    '나이': 20,
    '주소': ['서울특별시', '마포구', '목동'],
}
dict2 = dict({})
```

- Key 추출 방법

```python
dict1 = {
    '이름': '김일',
    '나이': 20,
    '주소': ['서울특별시', '마포구', '목동'],
}

print(dict1.keys())  # 출력값 : dict_keys(['이름', '나이', '주소'])
print(type(dict1.keys()))  # 출력값 : <class 'dict_keys'>
``` 

- value 추출 방법

```python
dict1 = {
    '이름': '김일',
    '나이': 20,
    '주소': ['서울특별시', '마포구', '목동'],
}

print(dict1.values())  # 출력값 : dict_values(['김일', 20, ['서울특별시', '마포구', '목동']])
print(type(dict1.values()))  # 출력값 : <class 'dict_values'>
```

- 추가 및 변경

```python
dict1 = {
    '이름': '김일',
    '나이': 20,
    '주소': ['서울특별시', '마포구', '목동'],
}

dict1['직업'] = '웹 퍼블리셔'
print(dict1)  # 출력값 : {'이름': '김일', '나이': 20, '주소': ['서울특별시', '마포구', '목동'], '직업': '웹 퍼블리셔'}

dict1['직업'] = '웹 개발자'
print(dict1)  # 출력값 : {'이름': '김일', '나이': 20, '주소': ['서울특별시', '마포구', '목동'], '직업': '웹 개발자'}

```

# Class

## 형식

- 클래스 정의 형식

```
class 클래스명(파스칼 케이스)
    본문
```

- 객체 생성 형식

```
객체이름 = 클래스명()
```

## 클래스의 구성

### 클래스의 기본 구성

- 객체를 만들어내는 클래스는 객체가 가져야 할 구성 요소를 지닙니다.
- 객체를 생성하기 위해서는 객체가 가져야 할'값'과 '기능'을 지녀야 합니다.
- 값 = 속성(attribute) , 기능 = 메서드(method)
- 클래스를 구성하는 속성은 두 가지로 구분됩니다.
    1. 클래스 변수 : 클래스를 기반으로 생성된 모든 인스턴스들이 공유하는 변수 -> 자바의 전역 변수
    2. 인스턴스 변수 : 인스턴스들이 개별적으로 가지는 변수
- 메서드는 특징에 따라서
    1. 클래스 메서드
    2. 정적 메서드
    3. 인스턴스 메서드
- 자바의 정적 메서드가 여기서는 클래스 메서드에 해당되고, 정적 메서드는 또 따로 전재한다.
- 그리고 Java에서의 this가 파이썬에서는 self에 해당한다.

## Constructor

- 형식

```python
class Sample:
    def __init__(self):
        print('인스턴스가 생성되었습니다.')
```

- 자바와는 다르게 `__init__`을 사용하여 생성자를 지정한다.

### 소멸자

- 형식

```python
class Sample:
    # 소멸자
    def __del__(self):
        print('인스턴스가 소멸되었습니다.')


sample = Sample()
del sample  # del 객체명
```

- 객체가 일정 코드라인 이후 사용되지 않아도 메모리를 할당하고 있는 문제가 발생한다.
- 이를 해결하기 위해서 할당을 해재하는 `del`혹은 소멸자가 존제한다.
- 이는 코드의 메모리 누수와 같이 옵티마이징할 때 자주 사용한다.

  