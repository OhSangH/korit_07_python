# 예외 처리의 필요성

1. 예외 : 개발자가 직접 처리할 수 있는 문제
2. 오류 : 개발자가 처리할 수 없는 문제
3. 예외 처리의 목적 : 어떤 문제가 발생 했을 때 그 문제를 해결해 주는것이 아니라, 발생된 문제로인해 프로그램이 비정상적으로 종료되는 것을 막고, 사용자에게 발생한 문제에 대해 정보를 전달하기 위함.

## 예외처리

1. 고전적 예외 처리
```python
a = int(input('나누는 수(제수)를 입력하세요. >> '))  # 0 입력
b = int(input('나눠지는 수(피제수)를 입력하세요. >> '))  # 1 입력
if a == 0:
    print('0으로 나눌 수 없습니다.')
else:
    result = b / a
``` 
   같은 방식으로 조건을 확인하여 예외를 작성하는 방식이다.

6. 사용자 정의 예외 처리

```python
class NegativeAgeError(Exception):
    pass
    # Exception 클래스를 상속 받았으면 슈퍼 클래스의 속성 / 메서드를 사용 할 수 있다.
    # 예외처리만 발생 시키면 되기에 굳이 추가 코드 작성은 필요없다.


try:
    age = int(input('나이를 입력하세요 >>>'))
    if age < 0:
        raise NegativeAgeError('나이는 음수일 수 없습니다.')
except NegativeAgeError as e:
    print(e)
```

같은 형식으로 직접 Exception을 상속 받아 예외클래스를 작성할 수 있으며 특정 조건에 예외로 동작시키는 것도 가능하다.

# 상속(Inheritance)

```python
class Person:
    def __init__(self, name):
        self.name = name

    def eat(self, food):
        print(f'{self.name}이(가) {food}를 먹습니다.')


class Student(Person):

    def __init__(self, name, school):
        super().__init__(name)
        self.school = school

    def study(self):
        print(f'{self.name}은(는) {self.school}에서 공부를 합니다.')


potter = Student('해리 포터', '호그와트')
potter.eat('감자')
potter.study()
```

이상의 코드에서 주목해야 할 점은

Student 클래스에 정의되지 않은 메서드인 .eat()을 76 라인에서 호출했다는 점.
Student 클래스의 생성자에서 확인되는 super().__init__(name)입니다.
해당 부분은 슈퍼 클래스의 생성자를 호출하는 방식입니다.
Java에서는 슈퍼 클래스의 생성자 호출 방식이 super()
Java에서 슈퍼 클래스의 메서드 호출 방식 super.메서드명()

```python
def eat(self, food):
    print(f'{self.school}에서', end=' ')
    super().eat(food)
```

만약에 이상과 같이 슈퍼 클래스의 메서드인 .eat()을 override하여 재정의하는 것도 가능합니다. Java와 달리 python에서는 기본적으로 super().을 베이스로 한다는 것을 알 수 있습니다. 생성자나
소멸자가 __ 가 앞뒤로 붙기는 하지만 기본적으로 method라는 사실을 알고 계신다면 Java보다 오히려 더 일괄적인 방식으로 코드를 작성한다는 점도 확인할 수 있겠습니다.